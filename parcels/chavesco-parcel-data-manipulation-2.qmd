---
title: "Heirs Property Rates By County"
format: html
editor: visual
---

# Packages

```{r}
library(tidyverse)
library(readxl)
library(writexl)
```

# Chaves

## Dataset

```{r}
chaves_parcels <- read_csv("/Users/timfarkas/repos/rural-estate-law/parcels/Chaves County Parcel Data All.csv")  
```

## **Remove Non-Real Property**

```{r}
chaves_parcels <- chaves_parcels[!is.na(chaves_parcels$CLASSCD1_DESC), ]
```

-   This removed 136 rows with column value "NA" for primary land code description

## Split Name Column Into Separate Names

(Creates a separate row for each owner with all other parcel data duplicated)

```{r}
#separate owners distinguished by ";" or "&", recognizing that if there is no last name after an &, it means it is a last name shared with the first name

library(dplyr)
library(tidyr)
library(stringr)
library(zoo)

# Common suffixes
# suffixes <- c("Jr", "Sr", "II", "III", "IV", "V")
suffixes <- c("JR", "SR", "II", "III")
# suffix_pattern <- paste0(",\\s*(", paste(suffixes, collapse = "|"), ")\\.?$")
suffix_pattern <- paste0("\\s(", paste(suffixes, collapse = "|"), ")$") # remove comma

# Step 1: Classify business vs. personal names
chaves_parcels <- chaves_parcels %>%
  mutate(
    is_business = !str_detect(NAME, ",")  # No comma → likely a business
  )

# Step 2: Separate business and non-business
businesses <- chaves_parcels %>% filter(is_business)
non_businesses <- chaves_parcels %>% filter(!is_business)

# Step 3: Normalize delimiters and separate names into rows
parsed <- non_businesses %>%
  mutate(NAME = str_replace_all(NAME, "\\s*[;&]\\s*", ";")) %>% # TODO: what about "& Sons" etc.?
  separate_rows(NAME, sep = ";") %>%
  mutate(NAME = str_trim(NAME))

# Step 4: Extract components
parsed <- parsed %>%
  mutate(
    has_comma = str_detect(NAME, ","),
    last_name = if_else(has_comma, str_trim(str_extract(NAME, "^[^,]+")), NA_character_),
    remainder = if_else(has_comma, str_trim(str_remove(NAME, "^[^,]+,")), str_trim(NAME)),
    # suffix = if_else(
    #   str_detect(remainder, suffix_pattern),
    #   str_extract(remainder, suffix_pattern) %>% str_remove_all(",\\s*|\\."),
    #   NA_character_
    # ),
    suffix = str_trim(str_extract(remainder, suffix_pattern)), 
    # given_names = str_trim(str_remove(remainder, suffix_pattern))
  )

# Step 5: Fill down last names where missing
parsed <- parsed %>%
  group_by(across(-c(NAME, last_name, remainder, given_names, has_comma, suffix))) %>%
  mutate(
    last_name = zoo::na.locf(last_name, na.rm = FALSE),
    NAME = case_when(
      !is.na(suffix) ~ str_c(last_name, given_names, suffix, sep = ", "),
      TRUE ~ str_c(last_name, given_names, sep = ", ")
    )
  ) %>%
  ungroup() %>%
  select(-last_name, -given_names, -remainder, -has_comma, -suffix)

# Step 6: Combine cleaned names with business names
chaves_owners <- bind_rows(parsed, businesses) %>% arrange(NAME)

# Preview
print(chaves_owners)


```

```{r}
# Test Suffix Regex
test_names <- "ALSTON, WILLIAM A JR"
str_extract(test_names, suffix_pattern) 
```

## Save Modified Dataset

```{r}
write_xlsx(chaves_owners, "Chaves County Parcel Owners Real Property Only.xlsx")
print("Data has been successfully transformed and saved as 'Chaves County Parcel Owners Real Property Only.xlsx'")
```

## Creating a Dataset Excluding Businesses

```{r}

library(dplyr)
library(stringr)
library(writexl)

# Updated filter to include business and institutional indicators, excluding trusts/estates
chaves_natural_owners <- chaves_owners %>%
  filter(
    !str_detect(
      toupper(NAME),
      "\\b(LLC|INC\\.?|INCORPORATED|LTD|CO\\.?|CHURCH|TRUST|TRUSTEE|IGLESIA|TEMPLE|ASSOC\\.?|ASSOCIATION|FOUNDATION|BOARD|TRUSTEES|LP|DAIRY|RANCH|PARTNERSHIP|BANK|LIMITED|PARTNERS|FARMS|PROPERTIES|PROPERTY|CITY|COUNTY|STATE|STATES|CORP\\.?|CORPORATION|LLLP|DEPT|PLC|ENTERPRISES|GROUP|COMPANY|MORTGAGE|CREDIT|FINANCIAL|LENDING|SERVICING|FUND|HOUSING|AUTHORITY|AGENCY|SCHOOL|UNIVERSITY|COLLEGE|INSTITUTE|CLUB|UNION|SOCIETY|TOWN|SERVICE)\\b|^ET AL$|^ET UX$"
    )
  )

# Save the cleaned dataset
write_xlsx(chaves_natural_owners, "Chaves Natural Owners Real Property Only.xlsx")

print("Filtered file has been successfully saved as 'Chaves Natural Owners Real Property Only.xlsx'")

```

## Removing Duplicate Name/Address Pairs

```{r}
# Load the Excel file
chaves_natural_owners <- read_excel("/Users/sophierane/Library/CloudStorage/OneDrive-UniversityofNewMexico/Rural Estate Planning Fellowship Research/Heirs Property/County Parcel Data/Chaves Natural Owners Real Property Only.xlsx")

# Remove duplicate rows based on NAME and ADDRESS
chaves_natural_owners_unique <- chaves_natural_owners %>%
  distinct(NAME, ADDRESS1, .keep_all = TRUE)  # Keeps only the first occurrence


```

```{r}

```

## Separate Last and First Name Into Two Columns

```{r}

library(dplyr)
library(stringr)

clean_names <- function(name) {
  suffixes <- c("Jr", "Sr", "II", "III", "IV", "V", "MD", "PhD", "Esq")
  
  parts <- str_split(name, ",\\s*")[[1]]
  parts <- str_trim(parts)
  
  last_name <- parts[1]
  suffix <- NA
  first_middle <- NA
  
  if (length(parts) == 2) {
    first_middle <- parts[2]
  } else if (length(parts) == 3) {
    # Check if the last part is a suffix
    if (parts[3] %in% suffixes) {
      first_middle <- parts[2]
      suffix <- parts[3]
    } else {
      # Unexpected structure
      first_middle <- paste(parts[2], parts[3], sep = ", ")
    }
  } else if (length(parts) > 3) {
    # Just in case — fallback for edge cases
    first_middle <- paste(parts[2:(length(parts) - 1)], collapse = ", ")
    suffix <- parts[length(parts)]
  } else {
    last_name <- NA
    first_middle <- name
  }
  
  return(data.frame(
    last_name = last_name,
    suffix = suffix,
    first_middle = first_middle,
    stringsAsFactors = FALSE
  ))
}

chaves_naturalowners_firstlast <- chaves_natural_owners_unique %>%
  rowwise() %>%
  do(bind_cols(., clean_names(.$NAME)))

# Save the cleaned dataset
write_xlsx(chaves_naturalowners_firstlast, "Chaves Natural Owners Ready for Processing.xlsx")

print("Duplicate name-address combinations removed! Saved as 'Chaves Natural Owners Ready for Processing.xlsx'.")

```

```{r}
```
